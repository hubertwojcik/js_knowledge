
---

# ğŸ§© VIII. Native Side â€” fundamenty pracy z warstwÄ… natywnÄ…

---

# ğŸ“± 1. RÃ³Å¼nice miÄ™dzy Androidem a iOS-em

## ğŸ¤– Android (Kotlin/Java)

- Bazuje na **Java/Kotlin**
- Budowany przez **Gradle**
- UI oparty o **Views**, XML layouty (ale RN ich nie uÅ¼ywa)
- Kod natywny w folderze:  
    `android/app/src/main/java/...`
- WywoÅ‚ania natywne przechodzÄ… przez **JNI â†’ JSI** (w nowej architekturze)

### Zalety:

- Å‚atwe logowanie (`Log.d()`)
- szybkie buildy na emulator
- hermetyczne zarzÄ…dzanie uprawnieniami (runtime permissions)

---

## ğŸ iOS (Swift/Objective-C)

- Bazuje na **Swift/Obj-C**
- Budowany przez **Xcode + Clang/LLVM**
- UI oparty o **UIView**
- Kod natywny w folderze:  
    `ios/YourApp/`

### Zalety:

- bardzo stabilne Å›rodowisko developerskie
- potÄ™Å¼ny debugger w Xcode
- spÃ³jne API

---

## ğŸ”¥ Kluczowe rÃ³Å¼nice praktyczne dla React Native:

|Obszar|Android|iOS|
|---|---|---|
|JÄ™zyk|Kotlin/Java|Swift/Obj-C|
|Build system|Gradle|Xcode Build|
|Logowanie|Logcat|Xcode console|
|Pliki konfiguracyjne|`build.gradle`|`Info.plist`, `Podfile`|
|Emulator|szybki, elastyczny|wolniejszy, stabilny|
|Debug native|Android Studio|Xcode|

---

# ğŸ§± 2. Podstawy tworzenia Native Modules

Native Module to **mostek miÄ™dzy JS a kodem natywnym**, potrzebny gdy:

- chcesz uÅ¼yÄ‡ API dostÄ™pnego tylko na platformie
- przetwarzasz ciÄ™Å¼kie dane szybciej natywnie
- chcesz mieÄ‡ dostÄ™p np. do Keychain, biometria, secure storage
- integrujesz bibliotekÄ™, ktÃ³ra nie ma paczki RN

---

## ğŸ”§ Android â€“ prosty przykÅ‚ad (Kotlin)

```kotlin
class MyModule(reactContext: ReactApplicationContext)
  : ReactContextBaseJavaModule(reactContext) {

  override fun getName() = "MyModule"

  @ReactMethod
  fun getValue(promise: Promise) {
    promise.resolve("Hello from Android")
  }
}
```

Rejestracja:

```kotlin
class MyPackage : ReactPackage {
  override fun createNativeModules(...) =
    listOf(MyModule(reactContext))
}
```

---

## ğŸ iOS â€“ prosty przykÅ‚ad (Swift)

```swift
@objc(MyModule)
class MyModule: NSObject {

  @objc
  func getValue(_ resolve: RCTPromiseResolveBlock,
                reject: RCTPromiseRejectBlock) {
      resolve("Hello from iOS")
  }
}
```

Rejestracja w Obj-C bridging header:

```objc
RCT_EXTERN_MODULE(MyModule, NSObject)
RCT_EXTERN_METHOD(getValue:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
```

---

# ğŸ§° 3. Jak dziaÅ‚a linking bibliotek

## ğŸ“¦ Automatyczny linking (React Native 0.60+)

- RN uÅ¼ywa **autolinking**
- `react-native.config.js` wskazuje, co i gdzie podpiÄ…Ä‡
- Android â†’ wpisy do `settings.gradle`, `build.gradle`
- iOS â†’ automatyczne dodanie do `Pods` przez CocoaPods

> Zwykle nie trzeba rÄ™cznie dodawaÄ‡ niczego â€” autolinking robi robotÄ™.

---

## ğŸ§© Manual linking (stare projekty / specyficzne biblioteki)

Czasem trzeba:

### Android:

- dodaÄ‡ moduÅ‚ do `settings.gradle`
- dopisaÄ‡ `apply plugin: ...`
- dodaÄ‡ dependency w `app/build.gradle`

### iOS:

- dopisaÄ‡ do `Podfile`
- wykonaÄ‡ `pod install`
- rÄ™cznie dodaÄ‡ frameworki do Xcode (rzadziej)

---

# ğŸ 4. Diagnostyka bÅ‚Ä™dÃ³w z Xcode / Android Studio

## ğŸ› Android Studio â€“ debugging

### NajczÄ™stsze problemy:

- Brak permission â†’ sprawdÅº manifest
- Crash na starcie â†’ logcat: `E/AndroidRuntime`
- BÅ‚Ä™dy Gradle â†’ zÅ‚e wersje SDK lub pakietÃ³w
- Incompatibility Hermes â†” biblioteka

NarzÄ™dzia:

- Logcat
- Build analyzer
- Memory profiler
- Layout inspector
- breakpoints w Kotlin/Java

---

## ğŸ Xcode â€“ debugging iOS

### Typowe bÅ‚Ä™dy:

- `unrecognized selector sent to instance` â†’ bÅ‚Ä…d Objective-C bridging
- bÅ‚Ä™dy linking â†’ framework nie dodany do projektu
- `Thread 1: signal SIGABRT` â†’ crash w natywnym kodzie
- zÅ‚a konfiguracja Info.plist (np. permissions)

NarzÄ™dzia:

- Breakpoints w Swift/Obj-C
- LLDB console (`po variable`)
- View debugger
- Memory Graph
- Crash logs (Organizer)

---

# ğŸ¤ Idealne zdania na rozmowÄ™

### ğŸ”¥ O rÃ³Å¼nicach Android/iOS:

â€NajwaÅ¼niejsze rÃ³Å¼nice to jÄ™zyk, build system i narzÄ™dzia â€” Android opiera siÄ™ na Kotlin/Gradle, a iOS na Swift/Xcode. RN generuje natywne komponenty w obu Å›rodowiskach, ale implementacja i debugging sÄ… inne.â€

### ğŸ”¥ O Native Modules:

â€Native Module to funkcja natywna udostÄ™pniona do JS. TworzÄ™ je, gdy bibliotekÄ™ trzeba zaadaptowaÄ‡ albo gdy dziaÅ‚anie musi byÄ‡ ultra szybkie lub natywne.â€

### ğŸ”¥ O linkingu:

â€RN ma autolinking od wersji 0.60, ktÃ³ry sam podÅ‚Ä…cza zaleÅ¼noÅ›ci na obu platformach. Manual linking potrzebny jest przy custom native modules lub starszych bibliotekach.â€

### ğŸ”¥ O debuggingu:

â€Na Androidzie uÅ¼ywam Logcat i breakpoints, a na iOS Xcode z LLDB. BÅ‚Ä™dy typu unrecognized selector to problemy z bridging, a SIGABRT czÄ™sto oznacza bÅ‚Ä…d konfiguracji.â€

---