
# ğŸ§  JavaScript â€” Jak dziaÅ‚a pod spodem  
### Call Stack â€¢ Event Loop â€¢ Heap â€¢ Garbage Collector â€¢ WydajnoÅ›Ä‡

Ten dokument zostaÅ‚ przygotowany tak, aby **Å›wietnie wyglÄ…daÅ‚ w Obsidianie**:  
duÅ¼o emoji, sekcje wizualne, idealny do nauki i powtÃ³rek przed rozmowÄ… rekrutacyjnÄ….

---

# ğŸš€ 1. Jak dziaÅ‚a JavaScript (Model wykonania)

JavaScript dziaÅ‚a w Å›rodowisku, ktÃ³re skÅ‚ada siÄ™ z:

- ğŸ§µ **GÅ‚Ã³wny wÄ…tek** â€” wykonuje caÅ‚y kod JS  
- ğŸ§± **Call Stack** â€” stos wywoÅ‚aÅ„ funkcji  
- ğŸ“¦ **Heap** â€” pamiÄ™Ä‡ na obiekty  
- ğŸ”„ **Event Loop** â€” pÄ™tla obsÅ‚ugujÄ…ca synchronicznoÅ›Ä‡ i asynchronicznoÅ›Ä‡  
- ğŸª£ **Garbage Collector (GC)** â€” automatyczne czyszczenie pamiÄ™ci

> â˜ï¸ **JS jest singleâ€‘threaded**, ale Å›rodowisko (przeglÄ…darka / Node / React Native) ma wÄ…tki pomocnicze.  
> Przez event loop wyniki wracajÄ… na gÅ‚Ã³wny wÄ…tek.

---

# ğŸ§± 2. Call Stack â€” stos wywoÅ‚aÅ„ funkcji

### ğŸ” Co to jest?

Call Stack to **struktura LIFO**, gdzie trafiajÄ… wszystkie wywoÅ‚ania funkcji.

### ğŸ”¹ Jak dziaÅ‚a?

1. Funkcja zostaje wywoÅ‚ana â†’ jej **execution context** trafia na stos  
2. Funkcja siÄ™ koÅ„czy â†’ kontekst jest zdejmowany  
3. Zawsze wykonywany jest element z **samego wierzchu**

### ğŸ”¥ PrzykÅ‚ad:

```
function a() { b(); }
function b() { c(); }
function c() { console.log("hi"); }

a();
```

Kolejno na stosie:

- global  
- a  
- b  
- c  

> ğŸ§¨ JeÅ›li stos jest zbyt gÅ‚Ä™boki dostaniesz:  
> **Maximum call stack size exceeded**

---

# ğŸ” 3. Event Loop â€” serce asynchronicznoÅ›ci

### ğŸ‘‰ JS wykonuje synchronicznie *wszystko* co jest na call stacku.

Asynchroniczne zadania trafiajÄ… do kolejek:

- ğŸŸ¦ **Microtask Queue** â€” Promise.then, await, queueMicrotask  
- ğŸŸ¥ **Macrotask Queue** â€” setTimeout, setInterval, I/O, UI events  

### ğŸ”¥ KolejnoÅ›Ä‡ w JS:

1. Wykonaj caÅ‚y kod synchroniczny  
2. OprÃ³Å¼nij **microtasks**  
3. Wykonaj 1 macrotask  
4. WrÃ³Ä‡ do punktu 2  

### ğŸŒŸ Kluczowe pytanie rekrutacyjne:

> Dlaczego `Promise.resolve().then()` wykonuje siÄ™ przed `setTimeout(..., 0)`?

ğŸ‘‰ Bo **microtasks majÄ… wyÅ¼szy priorytet niÅ¼ macrotasks**.

---

# ğŸ“¦ 4. Heap â€” pamiÄ™Ä‡ na obiekty

W **heapie** przechowywane sÄ…:

- obiekty `{}`,  
- tablice `[]`,  
- funkcje, closureâ€™y,  
- wszelkie struktury danych.

Zmienne na stosie zawierajÄ… jedynie **referencje** do obiektÃ³w w heapie.

---

# ğŸ—‘ï¸ 5. Garbage Collector â€” jak dziaÅ‚a?

JS uÅ¼ywa **algorytmu markâ€‘andâ€‘sweep**:

### ğŸ Faza 1: Mark
GC zaczyna od **rootÃ³w** (global, call stack, closures)  
i oznacza wszystkie obiekty, do ktÃ³rych moÅ¼na dotrzeÄ‡ referencjami.

### âœ‚ï¸ Faza 2: Sweep
Wszystko, do czego **nie da siÄ™ dotrzeÄ‡**, jest usuwane z pamiÄ™ci.

---

# ğŸŒ± 6. Generational GC â€” jak optymalizuje wydajnoÅ›Ä‡?

Nowoczesne silniki (V8, Hermes) dzielÄ… pamiÄ™Ä‡ na:

### ğŸŒ¿ MÅ‚odÄ… generacjÄ™ (New space)
- wiÄ™kszoÅ›Ä‡ obiektÃ³w Å¼yje krÃ³tko  
- szybkie sprzÄ…tanie (minor GC)

### ğŸŒ³ StarÄ… generacjÄ™ (Old space)
- obiekty Å¼yjÄ…ce dÅ‚uÅ¼ej  
- droÅ¼sze, rzadsze sprzÄ…tanie (major GC)

> ğŸ’¡ **Wniosek:**  
> DuÅ¼o krÃ³tkotrwaÅ‚ych obiektÃ³w â†’ OK  
> DuÅ¼e, dÅ‚ugo Å¼yjÄ…ce tablice â†’ uwaÅ¼aj na przecieki pamiÄ™ci.

---

# âš¡ 7. Co spowalnia GC i powoduje lagi?

### âŒ 1. Ogromne jednorazowe alokacje
Tworzenie duÅ¼ych tablic/obiektÃ³w na raz zmusza GC do czÄ™stszej pracy.

### âŒ 2. CiÄ…gÅ‚e generowanie nowych obiektÃ³w w pÄ™tli
Np. w React Native przy kaÅ¼dym renderze.

### âŒ 3. Kopiowanie duÅ¼ych tablic
`map`, `filter`, `slice`, spread operator  
â†’ generujÄ… nowe tablice â†’ praca dla GC

### âŒ 4. Trzymanie referencji â€przez przypadekâ€ (memory leaks)
- cache w globalnych zmiennych  
- nieusuwane event listenery  
- closure trzymajÄ…ce duÅ¼e obiekty  

---

# ğŸ§  8. Jak pisaÄ‡ wydajny kod pod GC?

### âœ… Reuse zamiast tworzyÄ‡ nowe

Zamiast:

```js
let arr2 = [...arr];
```

ZrÃ³b:

```js
for (let i = 0; i < arr.length; i++) {
  arr[i] *= 2;
}
```

### âœ… Przetwarzaj duÅ¼e dane â€w kawaÅ‚kachâ€
Chunking:

```
function processChunk(arr, size) {
  for (let i = 0; i < size; i++) { ... }
  requestAnimationFrame(() =>
      processChunk(arr.slice(size), size)
  );
}
```

### âœ… UwaÅ¼aj na closureâ€™y
Nie trzymajÄ… tylko logiki â€” **trzymajÄ… pamiÄ™Ä‡**, do ktÃ³rej majÄ… referencje.

### âœ… W React + React Native
- Nie twÃ³rz nowych funkcji w kaÅ¼dym renderze  
- uÅ¼ywaj `useMemo`, `useCallback`, `React.memo`  
- uwaÅ¼aj na massive map/filter w UI thread  

---
