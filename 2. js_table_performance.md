# âš¡ WydajnoÅ›Ä‡ pÄ™tli i metod tablicowych w JavaScript

## Dlaczego `for` jest szybszy od `map` / `filter` / `reduce` / `forEach`

â€**Metody tablicowe majÄ… narzut callbackÃ³w, tworzenia nowych tablic,
obsÅ‚ugi specyfikacji ECMA oraz abstrakcji iteratora.\
ZwykÅ‚a pÄ™tla `for` dziaÅ‚a bezpoÅ›rednio na indeksach, z minimalnÄ… liczbÄ…
warstw --- dlatego jest szybsza.**"

------------------------------------------------------------------------

# ğŸ§  Czym jest Execution Context?

Execution Context to Å›rodowisko, ktÃ³re silnik JS tworzy **za kaÅ¼dym
wywoÅ‚aniem funkcji**.

Zawiera: 
- ğŸ“ **Environment Record** 
	-  zmienne, parametry, funkcje
- ğŸ”— **Outer Environment Reference** 
	- dostÄ™p do scope chain
- ğŸ¯ **`this` binding**
- ğŸ§© **Mechanizmy kontroli wykonywania** (stack frame)

**NajwaÅ¼niejsze:**
â¡ï¸ *KaÅ¼de wywoÅ‚anie funkcji = nowy execution context*.
â¡ï¸ Dlatego metody tablicowe sÄ… wolniejsze --- tworzÄ… execution context
dla kaÅ¼dego elementu.

------------------------------------------------------------------------

# ğŸ”¥ Dlaczego `for` jest szybszy --- szczegÃ³Å‚owy podziaÅ‚

## 1. ğŸ“Œ Callback overhead (najwiÄ™kszy winowajca)

**Dotyczy wszystkich metod tablicowych**:
`map`, `filter`, `forEach`, `reduce`, `find`, `some`, `every`, `sort` (z
comparator).

Dla kaÅ¼dego elementu silnik musi: 
- WywoÅ‚uje funkcjÄ™ zwrotnÄ…
- stworzyÄ‡ nowy execution context, 
- ustawiÄ‡ stos wywoÅ‚aÅ„, 
- przekazaÄ‡ argumenty (`value`, `index`, `array`), 
- OceniÄ‡ wynik,
- WrzuciÄ‡ do nowej tablicy

Even gdy callback jest nazwany -- execution context **i tak powstaje**. Koszty wywoÅ‚ania jest bardzo duÅ¼y

------------------------------------------------------------------------

## 2. ğŸ§± Tworzenie nowych tablic (alokacje pamiÄ™ci)

  Metoda       Efekt                                        Koszt 
  ----------- --------------------------------- -------------------
  `map`    |  tworzy nowÄ… tablicÄ™ 1:1   |         **O(n) pamiÄ™ci**
  `filter`   tworzy tablicÄ™ podzbioru          |  **O(k)** pamiÄ™ci
  `flatMap`   rozbija + tworzy nowe struktury   **duÅ¼y narzut**
  `reduce`    zaleÅ¼y od implementacji           **O(1) lub O(n)**

Alokacje pamiÄ™ci zwiÄ™kszajÄ…: 
- czas kopiowania, 
- czÄ™stotliwoÅ›Ä‡ pracy Garbage Collectora.

------------------------------------------------------------------------

## 3. â›” Brak `break` i `continue`

Metody tablicowe **muszÄ… przejÅ›Ä‡ caÅ‚Ä… tablicÄ™**:\
â¡ï¸ zawsze minimum **O(n)**.

PÄ™tla:

``` js
for (let i = 0; i < arr.length; i++) {
  if (found) break;
}
```

â¡ï¸ moÅ¼e zatrzymaÄ‡ siÄ™ wczeÅ›niej â†’ **czÄ™sto szybsze w praktyce**.

------------------------------------------------------------------------

## 4. ğŸ§© Narzut specyfikacji ECMAScript

Metody tablicowe muszÄ… obsÅ‚uÅ¼yÄ‡: 
- sparse arrays (puste miejsca), 
- modyfikacje prototypÃ³w, 
- `thisArg`, - dziedziczenie, - array-like
structures, - walidacje typÃ³w.

PÄ™tla tego nie robi --- idzie â€prosto po indeksach".

------------------------------------------------------------------------

## 5. ğŸ”„ Chaining = wielokrotne przejÅ›cie tablicy

PrzykÅ‚ad:

``` js
arr.filter(...).map(...).reduce(...)
```

To **3 peÅ‚ne przebiegi tablicy** â†’ **O(3n)** czasu\
i potencjalnie **O(n)** dodatkowej pamiÄ™ci.

PÄ™tla:

``` js
for (const item of arr) {
  if (condition(item)) total += transform(item);
}
```

â¡ï¸ **jedno przejÅ›cie**: O(n)\
â¡ï¸ **brak dodatkowych tablic**: O(1)

------------------------------------------------------------------------

# ğŸ“Š ZÅ‚oÅ¼onoÅ›Ä‡ metod tablicowych -- Å‚adna tabela

    +-------------------------+---------------------+-------------------+--------------------+----------------------------------------------+
    | Metoda                  | Time Complexity     | Space Complexity  | Overhead           | Uwagi                                        |
    +-------------------------+---------------------+-------------------+--------------------+----------------------------------------------+
    | for                     | O(n)                | O(1)              | brak               | najszybsza opcja                             |
    | for...of                | O(n)                | O(1)              | lekki              | czytelny, ciut wolniejszy                    |
    | forEach                 | O(n)                | O(1)              | wysoki             | brak break                                   |
    | map                     | O(n)                | O(n)              | wysoki             | tworzy nowÄ… tablicÄ™                          |
    | filter                  | O(n)                | O(k)              | wysoki             | wielkoÅ›Ä‡ k zaleÅ¼y od filtra                  |
    | reduce                  | O(n)                | O(1)              | wysoki             | zaleÅ¼y od akumulatora                        |
    | some                    | O(n) worst          | O(1)              | Å›redni             | zatrzymuje siÄ™ gdy znajdzie                  |
    | every                   | O(n) worst          | O(1)              | Å›redni             | zatrzymuje siÄ™ gdy false                     |
    | find                    | O(n) worst          | O(1)              | Å›redni             | zatrzymuje siÄ™ gdy znajdzie                  |
    | findIndex               | O(n)                | O(1)              | Å›redni             | jw.                                          |
    | sort (bez comparatora)  | O(n log n)          | O(n)              | niski              | zoptymalizowany przez V8                     |
    | sort (z callbackiem)    | O(n log n Ã— cb)     | O(n)              | bardzo wysoki      | ogromny narzut callbackÃ³w                    |
    +-------------------------+---------------------+-------------------+--------------------+----------------------------------------------+

------------------------------------------------------------------------

# ğŸ Podsumowanie

### âœ”ï¸ Dlaczego `for` jest najszybszy?

-   brak callbackÃ³w
-   brak execution context per element\
-   brak tworzenia nowych tablic\
-   brak specyfikacyjnych narzutÃ³w\
-   lepsza optymalizacja JIT

### âœ”ï¸ Metody tablicowe sÄ… wygodne, ale:

-   majÄ… narzut funkcji (execution context),
-   nie przerywajÄ… pÄ™tli,
-   czÄ™sto alokujÄ… pamiÄ™Ä‡,
-   robiÄ… peÅ‚ne przebiegi tablicy,
-   zÅ‚oÅ¼onoÅ›Ä‡ czasowa/pamiÄ™ciowa jest w 100% przewidywalna: O(n).

------------------------------------------------------------------------

# ğŸ“ Koniec pliku
