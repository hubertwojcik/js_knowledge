
# ‚öõÔ∏è Core React & JavaScript ‚Äî Kompleksowa Notatka (Obsidian Style)


---

# üé£ 1. Czym jest Hook?

**Hook** to funkcja Reacta, kt√≥ra pozwala:
- korzystaƒá ze **stanu**,
- korzystaƒá z **cyklu ≈ºycia**,
- korzystaƒá z **kontekstu**,
- wyciƒÖgaƒá logikƒô do **re-u≈ºywalnych funkcji**.

Najwa≈ºniejsze cechy:
- dzia≈Ça tylko w **funkcjach komponent√≥w** i w≈Çasnych hookach,
- musi byƒá wywo≈Çywany **zawsze w tej samej kolejno≈õci** (regu≈Çy hook√≥w),
- pozwala na eleganckƒÖ separacjƒô logiki od UI.

> üé§ Idealna definicja na rozmowƒô:  
> ‚ÄûHook to funkcja, kt√≥ra ≈ÇƒÖczy Reacta z logikƒÖ komponentu, bez potrzeby klas i metod cyklu ≈ºycia.‚Äù

---

# üß† 2. Zaawansowane dzia≈Çanie React Hooks

## üîµ useEffect
S≈Çu≈ºy do wykonywania efekt√≥w ubocznych:

- fetch danych  
- subskrypcje  
- event listenery  
- synchronizacja z API lub storage  

**Zasada dzia≈Çania:**
- efekty uruchamiajƒÖ siƒô *po renderze*,
- dependency array decyduje, kiedy efekt siƒô wykona,
- cleanup wykonuje siƒô *przed kolejnym efektem* lub *przy odmontowaniu*.

---

## üü£ useMemo
S≈Çu≈ºy do **zapamiƒôtywania kosztownych oblicze≈Ñ**.

Przyk≈Çady u≈ºycia:
- filtrowanie du≈ºych list,
- generowanie struktur danych,
- parsowanie, mapowanie, sortowanie.

> React nie memoizuje nic automatycznie ‚Äî wszystko trzeba robiƒá ≈õwiadomie.

---

## üü° useCallback
Zwraca **zamemoizowanƒÖ funkcjƒô**, co:
- stabilizuje referencjƒô funkcji,
- pozwala uniknƒÖƒá zbƒôdnych re-render√≥w children,
- idealne z `React.memo`.

Najczƒô≈õciej u≈ºywane, gdy komponent podrzƒôdny ma props typu `onClick`, `onChange`.

---

# üî• 3. Re-rendering, batchowanie, memoizacja, performance

## üîÅ Co powoduje re-rendering?
- zmiana **props√≥w**
- zmiana **stanu**
- zmiana **kontekstu**
- re-render rodzica ‚Üí re-render dziecka (domy≈õlnie)

---

## üì¶ Batchowanie (React 18+)
React **grupuje setState** w tym samym ticku event loop ‚Üí 1 render zamiast wielu.

```
setA(1);
setB(2);
// tylko jeden re-render
```

---

## üßä React.memo
Zapobiega re-renderowi, je≈õli **propsy siƒô nie zmieni≈Çy**.

Skuteczne, gdy:
- du≈ºo komponent√≥w listy,
- ciƒô≈ºkie UI,
- stabilne referencje funkcji (useCallback),
- stabilne obiekty/arraye (useMemo, useRef).

---

## üß™ Profiling performance
Narzƒôdzia:
- React DevTools ‚Üí zak≈Çadka "Profiler"
- Flamegraphy
- sprawdzanie render count
- identyfikacja wasted renders

---

# üåÄ 4. Context API + wzorce architektoniczne

## üü¢ Context API
Pozwala przekazywaƒá dane bez props drillingu.

U≈ºywaj do:
- danych globalnych (theme, user, config),
- ale unikaj *nadmiernego* u≈ºycia ‚Äî context powoduje re-rendery wszystkich konsument√≥w.

Optymalizacje:
- dziel Context na mniejsze,
- u≈ºywaj `useContextSelector` lub biblioteki typu Jotai/Zustand,
- memoizuj warto≈õci przekazywane przez provider.

---

## üß© Wzorce architektoniczne

### üü¶ Container / Presentational
- **Container:** logika, fetch, state  
- **Presentational:** UI, layout

### üü® Hook extraction (custom hooks)
Pozwala:
- wyciƒÖgnƒÖƒá logikƒô,
- testowaƒá logikƒô bez UI,
- reu≈ºywaƒá behavior miƒôdzy komponentami.

Przyk≈Çad:

```
function useUser() {
  const [user, setUser] = useState(null);
  useEffect(() => fetchUser().then(setUser), []);
  return user;
}
```

---

# üîÑ 5. Event Loop ‚Äî Mikro & Makro Taski

JS ma jeden wƒÖtek wykonania. Reszta to system kolejek.

## üü£ Microtasks
- Promise.then
- await
- queueMicrotask
- MutationObserver

**Priorytet: najwy≈ºszy** ‚Äî wykonywane przed macrotasks.

## üî¥ Macrotasks
- setTimeout
- setInterval
- I/O
- UI events

Kolejno≈õƒá wykonania:
1. wykonaj ca≈Çy kod synchroniczny  
2. opr√≥≈ºnij microtasks  
3. wykonaj jeden macrotask  
4. wr√≥ƒá do microtasks  

> Dlatego `Promise.resolve().then()` wykona siƒô przed `setTimeout(() => ...)`.

---

# üß© 6. Scope, hoisting, prototypy, closures

## üìå Scope (zakresy)
Rodzaje:
- Global scope  
- Function scope  
- Block scope (`let`, `const`)  

JS dzia≈Ça na zasadzie **lexical scope** ‚Üí zakres zale≈ºy od miejsca w kodzie, a nie w runtime.

---

## üìå Hoisting
Deklaracje sƒÖ ‚Äûpodnoszone‚Äù do g√≥ry pliku:

- `var` jest hoistowany i inicjalizowany `undefined`
- `let`, `const` sƒÖ hoistowane, ale trafiajƒÖ do **TDZ** (Temporal Dead Zone)
- funkcje deklarowane jako `function` sƒÖ hoistowane w ca≈Ço≈õci

---

## üìå Prototypy
Ka≈ºdy obiekt ma ukryty link do `[[Prototype]]`.

Umo≈ºliwia:
- dziedziczenie,
- wsp√≥≈Çdzielenie metod,
- dzia≈Çanie `class` w JS (syntactic sugar nad prototypami).

---

## üìå Closures (zamykania)
Closure powstaje, gdy funkcja:
- ma dostƒôp do zmiennych z zewnƒôtrznego zakresu,
- nawet po zako≈Ñczeniu dzia≈Çania tego zakresu.

Przyk≈Çad:

```
function counter() {
  let x = 0;
  return () => x++;
}

const c = counter();
c(); // 1
c(); // 2
```

U≈ºywane do:
- enkapsulacji,
- tworzenia prywatnych zmiennych,
- budowy hook√≥w,
- logiki event handler√≥w.

---

