Jasne â€” poniÅ¼ej dostajesz **bardzo szczegÃ³Å‚owÄ…, seniorowÄ…, technicznie poprawnÄ… notatkÄ™**, ktÃ³ra wyjaÅ›nia **jak dziaÅ‚a React Native pod spodem**:  
Hermes â€¢ Bridge â€¢ JSI â€¢ Fabric â€¢ Yoga â€¢ Threads â€¢ Render pipeline

Zrobiona tak, abyÅ› mÃ³gÅ‚ recytowaÄ‡ to na rozmowie i brzmieÄ‡ jak ktoÅ›, kto zna RN od Å›rodka.

---

# ğŸ”¥ **Jak dziaÅ‚a React Native â€” peÅ‚na, techniczna notatka**

React Native to **hybrydowa platforma**, ktÃ³ra Å‚Ä…czy JavaScript z natywnymi widokami.  
Najlepiej myÅ›leÄ‡ o niej jako o **trzech duÅ¼ych warstwach**:

1. **JavaScript (JS Engine)** â€“ logika aplikacji, React, hooki
2. **Bridge / JSI** 
	-  komunikacja miÄ™dzy Å›wiatem JS a natywnym
	-  Faktyczne renderowanie widokÃ³w
3. **Native Infrastructure** â€“ renderer (Fabric), layout (Yoga), natywne wÄ…tki, moduÅ‚y

PrzejdÅºmy to szczegÃ³Å‚owo.

---

# ğŸ§  1. Hermes â€“ silnik JavaScript uÅ¼ywany w RN

Hermes to **zoptymalizowany silnik JS dla mobile**, stworzony przez Meta.  
ZastÄ…piÅ‚ V8/JSC jako domyÅ›lny engine.

## Dlaczego Hermes?

####  **Szybszy start aplikacji**

Hermes wykonuje _precompiled bytecode_, nie JS â†’ mniejszy czas uruchamiania.

####  **Mniejsze zuÅ¼ycie pamiÄ™ci**

Silnik jest zoptymalizowany na low-RAM devices (Android!).

####  **Lepszy GC**

Garbage Collector dziaÅ‚a **inkrementalnie**, dziÄ™ki czemu UI nie laguje.

####  **Wspiera JSI**

Bez Hermes RN nie moÅ¼e uÅ¼ywaÄ‡ nowej architektury.

> **KrÃ³tko:** Hermes to fundament nowej architektury RN, mniejszy, szybszy i lepiej dziaÅ‚a na Androidzie.

---

# ğŸ”Œ 2. Bridge â€” stara warstwa komunikacji (JS â†” Native)

W klasycznej architekturze RN dane miÄ™dzy JS a natywnÄ… warstwÄ… przechodziÅ‚y przez **Bridge**.

### Bridge:

- dziaÅ‚a **asynchronicznie**
- dane wysyÅ‚a jako **serializowany JSON**
- korzysta z dwÃ³ch wÄ…tkÃ³w:
    - **JS Thread**
    - **Native Modules Thread**

To generowaÅ‚o problemy:

### âŒ Overhead:

- koszt serializacji JSON
- duÅ¼a iloÅ›Ä‡ komunikatÃ³w przez kolejkÄ™
- brak synchronizacji JS â†’ Native
- wolne animacje (bo animacja zaleÅ¼aÅ‚a od JS Thread)

---

# ğŸ§© 3. JSI (JavaScript Interface) â€” nowy sposÃ³b komunikacji (bez Bridge)

JSI to **C++ API**, ktÃ³re daje JS bezpoÅ›redni dostÄ™p do funkcji natywnych.

### Co zmienia JSI?

#### Zero JSON â†’ brak serializacji

####  Bez kolejki Bridge â†’ natychmiastowa komunikacja

####  MoÅ¼liwy **synchron** (JS <-> Native)

####  MoÅ¼liwoÅ›Ä‡ tworzenia **TurboModules** i **Fabric Renderer**

####  MoÅ¼esz wykonywaÄ‡ kod natywny z pominiÄ™ciem JS Thread

> **JSI to najwiÄ™ksza rewolucja w RN od jego powstania.**

---

# ğŸ§± 4. TurboModules â€” nowy system natywnych moduÅ‚Ã³w

Stare Native Modules opieraÅ‚y siÄ™ na Bridge.

TurboModules dziaÅ‚ajÄ… na JSI.

### Zalety TurboModules:

âœ”ï¸ szybsze wywoÅ‚ania  
âœ”ï¸ mniej overheadu  
âœ”ï¸ generowane automatycznie przez codegen  
âœ”ï¸ mogÄ… dziaÅ‚aÄ‡ **synchronicznie** (np. pobranie wartoÅ›ci z Keychain)  
âœ”ï¸ lepsze zarzÄ…dzanie pamiÄ™ciÄ…

---

# ğŸ–¼ï¸ 5. Fabric â€” nowy renderer w RN

Fabric to nowy system renderowania, ktÃ³ry zastÄ™puje stary UI Manager.

### NajwaÅ¼niejsze korzyÅ›ci:

âœ”ï¸ **konkurencyjny rendering** (jak React 18 Concurrent Mode)  
âœ”ï¸ szybszy pipeline layoutu  
âœ”ï¸ stable host config dla natywnych widokÃ³w  
âœ”ï¸ lepsze batchowanie i scheduling  
âœ”ï¸ mniejszy narzut Bridge  
âœ”ï¸ wsparcie Layout Animations

### React creates a Virtual Tree â†’ Fabric serializes operations â†’ Native Renderer stosuje zmiany.

---

# ğŸ“ 6. Yoga â€” engine do layoutu (Flexbox)

Yoga to **biblioteka w C++**, ktÃ³ra liczy layout dla elementÃ³w RN.

React Native NIE uÅ¼ywa:

âœ˜ DOM  
âœ˜ CSSOM  
âœ˜ przeglÄ…darkowego layoutu

Zamiast tego:

### Yoga:

- liczy Flexbox w C++
- jest ultra szybka
- uÅ¼ywa go zarÃ³wno Android, jak i iOS
- wspiera: flex, margin, padding, justifyContent, alignItems, position

> â€RN implementuje wÅ‚asny layout engine w C++, dlatego zachowanie Flexboxa jest prawie takie samo jak w przeglÄ…darce, ale nie identyczne.â€

---

# ğŸ§µ 7. WÄ…tki w RN â€” jak dziaÅ‚a wielowÄ…tkowoÅ›Ä‡

RN nie dziaÅ‚a tylko na jednym wÄ…tku. SÄ… trzy kluczowe:

---

## ğŸŸ¦ **JS Thread**

- wykonuje JavaScript
- dziaÅ‚a React, hooki, state, logika aplikacji
- JEÅšLI go zablokujesz â†’ UI przestaje reagowaÄ‡

PrzykÅ‚ady blokujÄ…cych rzeczy:

- ciÄ™Å¼kie pÄ™tle
- sortowanie duÅ¼ych tablic
- parsing JSON (duÅ¼y)
- operacje matematyczne
- regexy

---

## ğŸŸ¥ **UI Thread (Main Thread)**

- odpowiada za **renderowanie**
- dotyki, gesty, animacje
- narysowanie komponentÃ³w na ekranie

JeÅ›li JS Thread jest przeciÄ…Å¼ony â†’ UI Thread nie dostaje nowych instrukcji â†’ **lagi**.

---

## ğŸŸ¨ **Native Modules Thread**

- wywoÅ‚ania natywnych funkcji
- operacje kamerÄ…, biometria, secure storage
- pliki, audio, Bluetooth

Bridge (w starej architekturze) komunikuje JS Thread z tym wÄ…tkiem.

---

## ğŸ”µ **JSI Threads**

W nowej architekturze moÅ¼esz tworzyÄ‡ swoje natywne wÄ…tki do zadaÅ„:

- kompresja
- video processing
- szyfrowanie
- heavy data filtering

I JS moÅ¼e ich uÅ¼ywaÄ‡ bez lagÃ³w.

---

# ğŸ–‡ï¸ 8. Pipeline dziaÅ‚ania React Native â€” krok po kroku

1. User wykonuje akcjÄ™ â†’ gest trafia na **UI Thread**
2. React przetwarza logikÄ™ na **JS Thread**
3. Tworzy Virtual Tree
4. Virtual Tree trafia do **Fabric** (C++)
5. Fabric okreÅ›la zmiany layoutu â†’ **Yoga** liczy pozycje
6. Fabric wysyÅ‚a instrukcje do **Native View Manager**
7. Native Thread aktualizuje widoki na ekranie

W nowej architekturze mniej pracy przechodzi przez Bridge â†’ duÅ¼o szybciej.

---

# ğŸ¤ Jak to powiedzieÄ‡ na rozmowie?

KrÃ³tko, seniorowo i precyzyjnie:

> â€React Native dziaÅ‚a dziÄ™ki trzem warstwom: silnikowi JS (Hermes), warstwie komunikacji (JSI zamiast Bridge) oraz natywnemu rendererowi (Fabric i Yoga). Hermes kompiluje kod do bytecode, JSI pozwala na synchronizacjÄ™ JS â†” Native bez serializacji, a Yoga liczy layout w C++. DziÄ™ki temu RN jest w stanie renderowaÄ‡ natywne komponenty zachowujÄ…c architekturÄ™ Reacta.â€

---