Jasne! Oto **Å›wietnie wyglÄ…dajÄ…ca, czytelna notatka** o **wydajnoÅ›ci w React Native** â€” idealna do Obsidiana i pod rozmowÄ™ technicznÄ….  
DuÅ¼o emoji, krÃ³tkie, celne wyjaÅ›nienia i zdania, ktÃ³re moÅ¼esz cytowaÄ‡.

---

# âš¡ V. Performance w React Native

### FlatList â€¢ SectionList â€¢ Virtualization â€¢ Threads â€¢ Renderowanie â€¢ Re-rendering

---

# ğŸ“š 1. Renderowanie list â€” FlatList & SectionList

W React Native **duÅ¼e listy to najwiÄ™kszy koszt renderowania UI**, dlatego RN stosuje **wirtualizacjÄ™ (windowing)**.

---

## ğŸªŸ 1.1. Na czym polega â€windowingâ€?

Nie renderujemy caÅ‚ej listy â€” tylko **maÅ‚e okno widocznych elementÃ³w + buffer**.

DziÄ™ki temu:

- mniejszy koszt renderowania,
- mniejsze zuÅ¼ycie pamiÄ™ci,
- pÅ‚ynniejszy scroll.

Aleâ€¦ to generuje problemy przy zÅ‚ej konfiguracji.

---

# ğŸ”§ 2. NajwaÅ¼niejsze optymalizacje FlatList/SectionList

## ğŸ§² 2.1. keyExtractor â€” absolutna podstawa

Zawsze uÅ¼ywaj **stabilnego klucza**, najlepiej `id`.

```js
keyExtractor={(item) => item.id}
```

> â— Å¹le dobrane klucze = masowe re-rendery + migotanie listy.

---

## ğŸ“ 2.2. getItemLayout â€” najwiÄ™kszy boost, jeÅ›li elementy majÄ… staÅ‚Ä… wysokoÅ›Ä‡

Pozwala RN **nie mierzyÄ‡** itemÃ³w podczas scrolla.

```js
getItemLayout={(data, index) => ({
  length: ITEM_HEIGHT,
  offset: ITEM_HEIGHT * index,
  index,
})}
```

Efekty:

- superpÅ‚ynny scroll,
- brak â€skakaniaâ€ przy przewijaniu,
- duÅ¼o mniej pracy dla JS.

> ğŸ¯ Idealny cytat:  
> â€getItemLayout eliminuje dynamiczne mierzenie itemÃ³w â€” to gigantyczny boost wydajnoÅ›ci.â€

---

## ğŸ“¦ 2.3. windowSize, initialNumToRender, maxToRenderPerBatch

UstawiajÄ…, **ile elementÃ³w widzi uÅ¼ytkownik** i **jak wiele trzeba wyrenderowaÄ‡ na starcie**.

### windowSize

- domyÅ›lnie: 21 viewportÃ³w
- im mniejsza lista â€” moÅ¼na zmniejszyÄ‡
- im lista dÅ‚uÅ¼sza â€” moÅ¼na zwiÄ™kszyÄ‡, by uniknÄ…Ä‡ â€pustych okienâ€

### initialNumToRender

Kontroluje â€first paintâ€.  
Nie przesadzaj â€” inaczej JS freeze na start.

### maxToRenderPerBatch

Ogranicza â€Å‚adowanie paczekâ€ itemÃ³w.

---

## ğŸ§Š 2.4. shouldRasterizeIOS / renderToHardwareTextureAndroid

Dla zÅ‚oÅ¼onych itemÃ³w moÅ¼na odciÄ…Å¼yÄ‡ compositing na GPU.

---

## ğŸ§© 2.5. memoizacja itemÃ³w

NajwaÅ¼niejsze zasady:

- opakuj item w **React.memo**
- funkcje przekazywane do itemÃ³w â†’ **useCallback**
- dane itemÃ³w â†’ stabilne referencje (useMemo)

```js
const Row = React.memo(({ item, onPress }) => {...});
```

To moÅ¼e zmniejszyÄ‡ re-render o **70â€“90%** przy duÅ¼ych listach.

---

# ğŸ› ï¸ 3. Virtualization Problems â€” najczÄ™stsze problemy

React Native zgÅ‚asza ostrzeÅ¼enie:

### âš ï¸ â€œVirtualizedLists should never be nested inside plain ScrollViewsâ€

Dlaczego?

- ScrollView wyrenderuje wszystko naraz â†’ gigantyczny koszt.
- VirtualizedList traci optymalizacje â†’ lagi.

RozwiÄ…zanie:

- uÅ¼ywaÄ‡ `nestedScrollEnabled`
- lub zamieniÄ‡ ScrollView na FlatList (z ListHeader, ListFooter)

---

## Inne problemy:

### â— â€Clipped subviewsâ€

Widoczne elementy nagle znikajÄ… lub pojawiajÄ… siÄ™ â†’ trzeba dostosowaÄ‡:

- `removeClippedSubviews={true}`
- poprawiÄ‡ style + height

### â— â€Blank areas during fast scrollâ€

Zbyt maÅ‚e okno â†’ zwiÄ™ksz:

- `windowSize`
- `maxToRenderPerBatch`

### â— â€Jank podczas scrollaâ€

NajczÄ™Å›ciej:

- ciÄ™Å¼ki `renderItem`
- animacje na JS thread
- duÅ¼e operacje na tabelach w renderze

---

# ğŸ§µ 4. Offloading pracy na threads (JS â†’ Native / Background)

React Native dziaÅ‚a na trzech gÅ‚Ã³wnych wÄ…tkach:

### ğŸŸ¦ JS Thread

UI logika, React, renderowanie VDOM.  
JeÅ›li zablokujesz â†’ UI stoi.

### ğŸŸ¥ UI Thread

Natywne renderowanie UI.

### ğŸŸ¨ Z tÅ‚a (Worker threads / JSI threads)

MoÅ¼esz delegowaÄ‡:

- ciÄ™Å¼kie parsowanie JSON
- filtrowanie duÅ¼ych datasetÃ³w
- operacje matematyczne
- sortowanie i mapowanie duÅ¼ych tablic

---

## ğŸ”¥ NarzÄ™dzia do offloadingu:

### 1. Reanimated (worklety)

DajÄ… natywne animacje â†’ brak lagÃ³w.

### 2. JSI (JavaScript Interface)

UmoÅ¼liwia:

- synchroniczny dostÄ™p do natywnych funkcji,
- wykonywanie obliczeÅ„ poza JS thread,
- budowÄ™ turbo-moduÅ‚Ã³w.

### 3. react-native-mmkv

BÅ‚yskawiczny storage oparty o JSI â†’ odciÄ…Å¼a JS.

### 4. Worker Threads (np. react-native-workers)

MoÅ¼esz wykonywaÄ‡ operacje w tle.

---

# ğŸ§¹ 5. Minimalizowanie re-renderÃ³w

To najwaÅ¼niejszy temat, jeÅ›li chcesz brzmieÄ‡ PRO.

---

## ğŸ”µ 5.1. Stabilne referencje

React re-renderuje komponenty **gdy zmieniajÄ… siÄ™ propsy**.  
Zmiana referencji = nowy render.

RozwiÄ…zania:

- `useMemo` dla obiektÃ³w
- `useCallback` dla funkcji
- `React.memo` dla komponentÃ³w

---

## ğŸŸ£ 5.2. Internal state â†’ minimalny i pÅ‚aski

DuÅ¼y state = duÅ¼o re-renderÃ³w.  
Lepszy pattern:

```js
const [value, setValue] = useState("");
```

niÅ¼:

```js
const [form, setForm] = useState({ value: "" });
```

---

## ğŸŸ  5.3. Unikanie anon funkcji w renderze

ZÅ‚e:

```js
onPress={() => something()}
```

Lepiej:

```js
const onPress = useCallback(() => something(), []);
```

---

## ğŸŸ¢ 5.4. Heavy computations â†’ useMemo

JeÅ›li masz:

- filtrowanie
- sortowanie
- mapowanie
- agregacje duÅ¼ych danych

Nie rÃ³b tego w renderze.

---

## ğŸ§© 5.5. W React Native szczegÃ³lnie:

- animacje: Reanimated (nie JS thread)
- gesty: Gesture Handler (nie JS thread)
- listy: duÅ¼y nacisk na okna i memoizacjÄ™

---

# ğŸ¤ Idealne zdania na rozmowÄ™

### ğŸŸ¦ O listach:

â€FlatList jest szybka dziÄ™ki wirtualizacji i renderowaniu tylko okna elementÃ³w. Kluczowymi optymalizacjami sÄ…: getItemLayout, memoizacja itemÃ³w i stabilne keyExtractor.â€

### ğŸŸ¥ O offloadingu:

â€CiÄ™Å¼kie operacje przenoszÄ™ z JS Thread na natywnÄ… warstwÄ™ â€” przez JSI lub worklety Reanimated â€” dziÄ™ki czemu UI pozostaje pÅ‚ynne.â€

### ğŸŸ© O re-renderach:

â€Stabilne referencje + React.memo to fundament redukcji niepotrzebnych re-renderÃ³w. W listach daje to najwiÄ™ksze oszczÄ™dnoÅ›ci.â€

### ğŸŸ§ O virtualization problems:

â€NajczÄ™stszy problem to zagnieÅ¼dÅ¼anie VirtualizedList w ScrollView â€” tracimy windowing i lista renderuje siÄ™ caÅ‚a.â€

---
